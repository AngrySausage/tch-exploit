{ EventEmitter } = require 'events'

util = require 'util'
dgram = require 'dgram'

class TimeServer extends EventEmitter
  constructor: (time, error, version, mode, stratum, delay, dispersion) ->
    super

    @_socket = dgram.createSocket('udp4')

    #0=no error, 1=last minute of the day has 61 seconds, 2=last minute of the day has 59 seconds, 3=unknown
    ntp_server_error = ('0' + parseInt(error, 10).toString(2)).slice(-2)

    #integer showing NTP server version
    ntp_server_version = ('00' + parseInt(version, 10).toString(2)).slice(-3)

    #0=reserved, 1=symmetric active, 2=symmetric passice, 3=client, 4=server, 5=broadcast, 6=NTP control message, 7=reserved for private use
    ntp_server_mode = ('00' + parseInt(mode, 10).toString(2)).slice(-3)

    #0=unspecified, 1=primary, 2-15=secondary, 16=unsychronized
    ntp_peer_clock_stratum = '1'
    ntp_peer_clock_precision = '128'

    #0.000 - 9.999
    ntp_root_delay = '0.9900'

    #0.000 - 9.999
    ntp_root_dispersion = '0.9900'

    #seconds since 1.1.1900, needs to be added for NTP to date generated by new Date()
    ntp_seconds_since_epoch = '2208988800'

    #provided reference ID
    ntp_reference_id = [ 78, 85, 76, 76 ]

    if time is ''
      createTime = 'recent'
    else
      createTime = (parseInt(new Date / 1000) - parseInt(time)).toString()

    @_socket.on 'message', (msg, rinfo) =>
      @emit 'data', 'received message from ' + rinfo.address + ':' + rinfo.port

      if createTime == 'recent'
        timestamp = (new Date / 1000).toString()
      else
        timestamp = (parseInt(new Date / 1000) - parseInt(createTime)).toString()

      # set flags
      msg.writeUIntBE parseInt(ntp_server_error + ntp_server_version + ntp_server_mode, 2), 0, 1

      # set peer clock stratum
      msg.writeUIntBE parseInt(ntp_peer_clock_stratum, 10), 1, 1

      # set peer clock precision
      msg.writeUIntBE parseInt(ntp_peer_clock_precision, 10), 3, 1

      # set root delay seconds
      msg.writeUIntBE ntp_root_delay.before(), 4, 2

      # set root delay fraction
      msg.writeUIntBE 65535 / 10000 * ntp_root_delay.after(), 6, 2

      # set root dispersion seconds
      msg.writeUIntBE parseInt(ntp_root_dispersion.before(), 10), 8, 2

      # set root dispersion fraction
      msg.writeUIntBE 65535 / 10000 * ntp_root_dispersion.after(), 10, 2

      #set reference ID
      msg.writeUIntBE parseInt(ntp_reference_id[0], 10), 12, 1
      msg.writeUIntBE parseInt(ntp_reference_id[1], 10), 13, 1
      msg.writeUIntBE parseInt(ntp_reference_id[2], 10), 14, 1
      msg.writeUIntBE parseInt(ntp_reference_id[3], 10), 15, 1

      # set reference timestamp
      msg.writeUIntBE parseInt(ntp_seconds_since_epoch, 10) + timestamp.before(), 16, 4

      # set origin timestamp
      msg.writeUIntBE parseInt(ntp_seconds_since_epoch, 10) + timestamp.before(), 24, 4

      # set receive timestamp
      msg.writeUIntBE parseInt(ntp_seconds_since_epoch, 10) + timestamp.before(), 32, 4

      # set transmit timestamp
      msg.writeUIntBE parseInt(ntp_seconds_since_epoch, 10) + timestamp.before(), 40, 4

      @_socket.send msg, 0, msg.length, rinfo.port, rinfo.address, (err, bytes) =>
        if err
          throw err

        @emit 'data', 'send response to ' + rinfo.address + ':' + rinfo.port

    @_socket.on 'listening', =>
      address = @_socket.address()

      @emit 'data', 'server listening ' + address.address + ':' + address.port

    @_socket.on 'error', (err) =>
      @emit 'data', err

    @_socket.bind 123

String::before = ->
  value = parseInt(@toString().split('.')[0], 10)
  #before
  if value then value else 0

String::after = ->
  value = parseInt(@toString().split('.')[1], 10)
  #after
  if value then value else 0

server = new TimeServer('1220580245', '0', '4', '4', '1', '0.9900', '0.9900')

server.on 'data', (output) ->
  console.log output

module.exports = TimeServer
