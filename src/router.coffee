param = (val) ->
  (map) -> map[val]

str = (val) ->
  -> val

formatter = (format) ->
  if !format
    return null

  format = format.replace(/\{\*\}/g, '*').replace(/\*/g, '{*}').replace(/:(\w+)/g, '{$1}')

  format = format.match(/(?:[^\{]+)|(?:{[^\}]+\})/g).map (item) ->
    if item[0] != '{' then str(item) else param(item.substring(1, item.length - 1))

  (params) ->
    format.reduce (result, item) ->
      result + item(params)
    , ''

decode = (str) ->
  try
    decodeURIComponent(str)
  catch err
    str

matcher = (pattern) ->
  if typeof pattern != 'string'
    return (url) ->
      url.match pattern

  keys = []

  pattern = pattern.replace(/:(\w+)/g, '{$1}').replace('{*}', '*')

  pattern = pattern.replace /(\/)?(\.)?\{([^}]+)\}(?:\(([^)]*)\))?(\?)?/g, (match, slash, dot, key, capture, opt, offset) ->
    incl = (pattern[match.length + offset] or '/') == '/'
    keys.push key
    (if incl then '(?:' else '') + (slash or '') + (if incl then '' else '(?:') + (dot or '') + '(' + (capture or '[^/]+') + '))' + (opt or '')

  pattern = pattern.replace(/([\/.])/g, '\\$1').replace(/\*/g, '(.+)')
  pattern = new RegExp('^' + pattern + '[\\/]?$', 'i')

  (str) ->
    match = str.match(pattern)

    if !match
      return match

    map = {}

    match.slice(1).forEach (param, i) ->
      k = keys[i] = keys[i] or 'wildcard'
      param = param and decode(param)
      map[k] = if map[k] then [].concat(map[k]).concat(param) else param

    if map.wildcard
      map['*'] = map.wildcard

    map

METHODS = [
  'get'
  'post'
  'put'
  'del'
  'delete'
  'head'
  'options'
]

HTTP_METHODS = [
  'GET'
  'POST'
  'PUT'
  'DELETE'
  'DELETE'
  'HEAD'
  'OPTIONS'
]

noop = ->

error = (res) ->
  ->
    res.statusCode = 404
    res.end()
    return

router = ->
  methods = {}
  traps = {}

  HTTP_METHODS.forEach (method) ->
    methods[method] = []

  route = (req, res, next) ->
    method = methods[req.method]

    trap = traps[req.method]
    index = req.url.indexOf('?')

    url = if index == -1 then req.url else req.url.substr(0, index)

    i = 0

    next = next or error(res)

    if !method
      return next()

    lp = (err) ->
      if err
        return next(err)

      while i < method.length
        route = method[i]
        i++

        req.params = route.pattern(url)

        if !req.params
          continue

        if route.rewrite
          req.url = url = route.rewrite(req.params) + (if index == -1 then '' else req.url.substr(index))

        route.fn req, res, lp
        return

      if !trap
        return next()

      trap req, res, next

      return

    lp()

    return

  METHODS.forEach (method, i) ->

    route[method] = (pattern, rewrite, fn) ->
      if Array.isArray(pattern)
        pattern.forEach (item) ->
          route[method] item, rewrite, fn

      if !fn and !rewrite
        return route[method](null, null, pattern)

      if !fn and typeof rewrite == 'string'
        return route[method](pattern, rewrite, route)

      if !fn and typeof rewrite == 'function'
        return route[method](pattern, null, rewrite)

      if !fn
        return route

      (route.onmount or noop) pattern, rewrite, fn

      if !pattern
        traps[HTTP_METHODS[i]] = fn
        return route

      methods[HTTP_METHODS[i]].push
        pattern: matcher(pattern)
        rewrite: formatter(rewrite)
        fn: fn

      route

    return

  route.all = (pattern, rewrite, fn) ->
    METHODS.forEach (method) ->
      route[method] pattern, rewrite, fn

    route

  route

module.exports = router()
