Options = require('./options').opts

trimZero = (str) ->
  pos = str.indexOf('\u0000')

  if pos == -1 then str else str.substr(0, pos)

class SeqBuffer
  constructor: (buf, len) ->
    @_data = buf or Buffer.alloc(len or 1500)

  _data: null
  _r: 0
  _w: 0

  addUInt8: (val) ->
    @_w = @_data.writeUInt8(val, @_w, true)

  getUInt8: ->
    @_data.readUInt8 @_r++, true

  addInt8: (val) ->
    @_w = @_data.writeInt8(val, @_w, true)

  getInt8: ->
    @_data.readInt8 @_r++, true

  addUInt16: (val) ->
    @_w = @_data.writeUInt16BE(val, @_w, true)

  getUInt16: ->
    @_data.readUInt16BE (@_r += 2) - 2, true

  addInt16: (val) ->
    @_w = @_data.writeInt16BE(val, @_w, true)

  getInt16: ->
    @_data.readInt16BE (@_r += 2) - 2, true

  addUInt32: (val) ->
    @_w = @_data.writeUInt32BE(val, @_w, true)

  getUInt32: ->
    @_data.readUInt32BE (@_r += 4) - 4, true

  addInt32: (val) ->
    @_w = @_data.writeInt32BE(val, @_w, true)

  getInt32: ->
    @_data.readInt32BE (@_r += 4) - 4, true

  addUTF8: (val) ->
    @_w += @_data.write(val, @_w, 'utf8')

  addUTF8Pad: (val, fixLen) ->
    len = Buffer.from(val, 'utf8').length
    n = 0

    while len > fixLen
      val = val.slice(0, fixLen - n)
      len = Buffer.from(val, 'utf8').length

      n++

    @_data.fill 0, @_w, @_w + fixLen
    @_data.write val, @_w, 'utf8'

    @_w += fixLen

  getUTF8: (len) ->
    trimZero @_data.toString('utf8', @_r, @_r += len)

  addASCII: (val) ->
    @_w += @_data.write(val, @_w, 'ascii')

  addASCIIPad: (val, fixLen) ->
    @_data.fill 0, @_w, @_w + fixLen
    @_data.write val.slice(0, fixLen), @_w, 'ascii'

    @_w += fixLen

  getASCII: (len) ->
    trimZero @_data.toString('ascii', @_r, @_r += len)

  addIP: (ip) ->
    return unless typeof ip is 'string'
    
    octs = ip.split('.')

    if octs.length != 4
      throw new Error('Invalid IP address ' + ip)

    for val in octs
      val = parseInt(val, 10)

      if 0 <= val and val < 256
        @addUInt8 val
      else
        throw new Error('Invalid IP address ' + ip)

  getIP: ->
    @getUInt8() + '.' + @getUInt8() + '.' + @getUInt8() + '.' + @getUInt8()

  addIPs: (ips) ->
    if ips instanceof Array
      for ip in ips
        @addIP ip
    else
      @addIP ips

  getIPs: (len) ->
    ret = []
    i = 0

    while i < len
      ret.push @getIP()
      i += 4

    ret

  addHex: (val, fixLen) ->
    if fixLen
      @_data.fill 0, @_w, @_w + fixLen
      @_data.write val.slice(0, fixLen), @_w, 'hex'

      @_w += fixLen
    else
      @_w += @_data.write(val, @_w, 'hex')

  getHEX: (hlen) ->
    @_data.toString 'hex', @_r, @_r += hlen

  addMac: (mac) ->
    octs = mac.split(/[-:]/)

    if octs.length != 6
      throw new Error('Invalid Mac address ' + mac)

    for val in octs
      val = parseInt(val, 16)

      if 0 <= val and val < 256
        @addUInt8 val
      else
        throw new Error('Invalid Mac address ' + mac)

    @addUInt32 0
    @addUInt32 0
    @addUInt16 0

  getMAC: (htype, hlen) ->
    mac = @_data.toString('hex', @_r, @_r += hlen)

    if htype != 1 or hlen != 6
      throw new Error('Invalid hardware address (len=' + hlen + ', type=' + htype + ')')

    @_r += 10

    mac.toUpperCase().match(/../g).join '-'

  addBool: ->
    return

  getBool: ->
    true

  addOptions: (opts) ->

    for own i, val of opts
      opt = Options[i]
      len = 0

      if val == null
        i += 4
        continue

      switch opt.type
        when 'UInt8', 'Int8'
          len = 1
        when 'UInt16', 'Int16'
          len = 2
        when 'UInt32', 'Int32', 'IP'
          len = 4
        when 'IPs'
          len = if val instanceof Array then 4 * val.length else 4
        when 'ASCII'
          len = val.length

          if len == 0
            i += 4
            continue

          if len > 255
            console.error val + ' too long, truncating...'
            val = val.slice 0, 255
            len = 255
        when 'HEX'
          len = val.length

          if len is 0
            continue

          if len > 255
            console.error val + ' too long, truncating...'

            val = val.slice 0, 255
            len = 255

        when 'UTF8'
          len = Buffer.from(val, 'utf8').length

          if len == 0
            i += 4
            continue

          n = 0

          while len > 255
            val = val.slice(0, 255 - n)
            len = Buffer.from(val, 'utf8').length

            n++
        when 'Bool'
          if !(val == true or val == 1 or val == '1' or val == 'true' or val == 'TRUE' or val == 'True')
            n++
            continue
        when 'UInt8s'
          len = if val instanceof Array then val.length else 1
        when 'UInt16s'
          len = if val instanceof Array then 2 * val.length else 2
        else
          throw new Error('No such type ' + opt.type)

      @addUInt8 i
      @addUInt8 len

      @['add' + opt.type] val

  getOptions: ->
    options = {}

    buf = @_data

    while @_r < buf.length
      opt = @getUInt8()

      if opt == 0xff
        break
      else if opt == 0x00
        @_r++
      else
        len = @getUInt8()

        if opt of Options
          options[opt] = @['get' + Options[opt].type](len)
        else
          @_r += len

          console.error 'Option ' + opt + ' not known'

    options

  addUInt8s: (arr) ->
    if arr instanceof Array
      i = 0

      while i < arr.length
        @addUInt8 arr[i]
        i++
    else
      @addUInt8 arr

  getUInt8s: (len) ->
    ret = []
    i = 0

    while i < len
      ret.push @getUInt8()
      i++

    ret

  addUInt16s: (arr) ->
    if arr instanceof Array
      i = 0

      while i < arr.length
        @addUInt16 arr[i]
        i++
    else
      @addUInt16 arr

  getUInt16s: (len) ->
    ret = []
    i = 0

    while i < len
      ret.push @getUInt16()
      i += 2

    ret

  getHex: (len) ->
    @_data.toString 'hex', @_r, @_r += len

module.exports = SeqBuffer
