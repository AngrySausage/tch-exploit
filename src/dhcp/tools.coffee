module.exports =

  parseIp: (str) ->
    octs = str.split('.')

    if octs.length != 4
      throw new Error('Invalid IP address ' + str)

    octs.reduce (prev, val) ->
      val = parseInt(val, 10)

      if 0 <= val and val < 256
        return prev << 8 | val
      else
        throw new Error('Invalid IP address ' + str)

      return
    , 0
    
  formatIp: (num) ->
    ip = ''
    i = 24

    while i >= 0
      if ip
        ip += '.'

      ip += (num >>> i & 0xFF).toString(10)
      i -= 8

    ip

  netmaskFromCIDR: (cidr) ->
    -1 << 32 - cidr

  netmaskFromIP: (ip) ->
    if typeof ip == 'string'
      ip = @parseIp(ip)

    first = ip >>> 24

    if first <= 127
      0xff000000
    else if first >= 192
      0xffffff00
    else
      0xffff0000

  wildcardFromCIDR: (cidr) ->
    ~@netmaskFromCIDR(cidr)

  networkFromIpCIDR: (ip, cidr) ->
    if typeof ip == 'string'
      ip = @parseIp(ip)

    @netmaskFromCIDR(cidr) & ip

  broadcastFromIpCIDR: (ip, cidr) ->
    if typeof ip == 'string'
      ip = @parseIp(ip)

    @networkFromIpCIDR(ip, cidr) | @wildcardFromCIDR(cidr)

  CIDRFromNetmask: (net) ->
    if typeof net == 'string'
      net = @parseIp(net)

    s = 0
    d = 0

    t = net & 1
    wild = t
    i = 0

    while i < 32
      d += t ^ net & 1
      t = net & 1

      net >>>= 1

      s += t
      i++

    if d != 1
      throw new Error('Invalid Netmask ' + net)

    if wild
      s = 32 - s

    s

  gatewayFromIpCIDR: (ip, cidr) ->
    if typeof ip == 'string'
      ip = @parseIp(ip)

    if cidr == 32
      return ip

    @networkFromIpCIDR(ip, cidr) + 1

  netmaskFromRange: (ip1, ip2) ->
    if typeof ip1 == 'string'
      ip1 = @parseIp(ip1)

    if typeof ip2 == 'string'
      ip2 = @parseIp(ip2)

    cidr = 32 - Math.floor(Math.log2((ip1 ^ ip2 - 1) + 2)) - 1

    @netmaskFromCIDR cidr
