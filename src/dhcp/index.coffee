dgram = require 'dgram'
os = require 'os'

{ EventEmitter } = require 'events'

Lease = require './lease'
SeqBuffer = require './seqbuffer'
Options = require './options'
Protocol = require './protocol'
Tools = require './tools'

{
  DHCPDISCOVER, DHCPOFFER, DHCPREQUEST, DHCPDECLINE
  DHCPACK, DHCPNAK, DHCPRELEASE, DHCPINFORM
  SERVER_PORT, CLIENT_PORT
  INADDR_ANY, INADDR_BROADCAST
  BOOTREQUEST, BOOTREPLY, DHCPV6
} = require './constants'

class Server extends EventEmitter
  @createServer: (opt) ->
    new Server(opt)

  constructor: (config) ->
    super

    sock = dgram.createSocket
      type: 'udp4'
      reuseAddr: true

    sock.on 'message', @ipv4Message.bind @

    sock.on 'listening', =>
      @emit 'listening', sock, ''

    sock.on 'close', =>
      @emit 'close'

    sock6 = dgram.createSocket
      type: 'udp6'
      reuseAddr: true

    sock6.on 'message', @ipv6Message.bind @

    sock6.on 'listening', =>
      @emit 'listening', sock6, 'v6'

    sock6.on 'close', =>
      @emit 'close'

    @_sock6 = sock6
    @_sock = sock

    @_conf = config
    @_state = {}

  ipv4Message: (buf) ->
    try
      req = Protocol.parse(buf)
    catch e
      @emit 'error', e
      return

    @emit 'message', req

    if req.op != BOOTREQUEST
      @emit 'error', new Error('Malformed packet'), req
      return

    if not req.options[53]
      return @handleRequest req

    switch req.options[53]
      when DHCPDISCOVER
        @handleDiscover req
      when DHCPREQUEST
        @handleRequest req

  ipv6Message: (buf, rinfo) ->
    try
      req = Protocol.parseIpv6(buf)
    catch e
      @emit 'error', e
      return

    @emit 'message', req

    @emit DHCPV6.MESSAGETYPE[req.op], req, rinfo

  config: (key) ->
    optId = Options.conf[key]

    if undefined != @_conf[key]
      val = @_conf[key]
    else if undefined != Options.opts[optId]
      val = Options.opts[optId].default

      if val == undefined
        return 0
    else
      throw new Error 'Invalid option ' + key

    if val instanceof Function
      val = val.call @

    values = Options.opts[optId]?.enum

    if key not in [ 'range', 'static', 'randomIP' ] and values
      for i, v of values when v is val
        return parseInt i, 10

      if values[val] is undefined
        throw new Error 'Provided enum value for ' + key + ' is not valid'
      else
        val = parseInt val, 10

    val

  _getOptions: (pre, required, requested) ->
    for req in required
      if Options.opts[req] != undefined
        pre[req] ?= @config(Options.opts[req].config)

        if not pre[req]
          throw new Error "Required option #{ Options.opts[req].config } does not have a value set"
      else
        @emit 'error', 'Unknown option ' + req

    if requested
      for req in requested
        if Options.opts[req] isnt undefined and pre[req] is undefined
          val = @config(Options.opts[req].config)

          if val
            pre[req] = val
        else
          @emit 'error', 'Unknown option ' + req

    forceOptions = @_conf.forceOptions

    if Array.isArray forceOptions

      for option in forceOptions
        if isNaN option
          id = Options.conf[option]
        else
          id = option

        if id? and pre[id] is undefined
          pre[id] = @config(option)

    pre

  _selectAddress: (clientMAC, req) ->
    if  @_state[clientMAC]?.address
      return @_state[clientMAC].address

    _static = @config 'static'

    if typeof _static is 'function'
      staticResult = _static clientMAC, req

      if staticResult
        return staticResult
    else if _static[clientMAC]
      return _static[clientMAC]

    randIP = @config 'randomIP'
    _tmp = @config 'range'

    firstIP = Tools.parseIp _tmp[0]
    lastIP = Tools.parseIp _tmp[1]

    ips = [ @config('server') ]

    oldestMac = null
    oldestTime = Infinity

    leases = 0

    for mac, v of @_state
      if v.address
        ips.push v.address

      if v.leaseTime < oldestTime
        oldestTime = v.leaseTime
        oldestMac = mac

      leases++

    if oldestMac and lastIP - firstIP == leases
      ip = @_state[oldestMac].address

      delete @_state[oldestMac]

      return ip

    if randIP
      loop
        ip = Tools.formatIp(firstIP + Math.random() * (lastIP - firstIP) | 0)

        if ips.indexOf(ip) == -1
          return ip

    i = firstIP

    while i <= lastIP
      ip = Tools.formatIp i

      if ip not in ips
        return ip

      i++

  handleDiscover: (req) ->
    lease = @_state[req.chaddr] = @_state[req.chaddr] or new Lease
    lease.address = @_selectAddress(req.chaddr, req)
    lease.leasePeriod = @config 'leaseTime'
    lease.server = @config 'server'
    lease.state = 'OFFERED'

    console.log '>>> DISCOVER', JSON.stringify lease

    @sendOffer req

  sendOffer: (req) ->
    if req.options[97] and req.options[55].indexOf(97) == -1
      req.options[55].push 97

    if req.options[60] and req.options[60].indexOf('PXEClient') == 0
      [ 66, 67 ].forEach (opt) ->
        if req.options[55].indexOf(opt) is -1
          req.options[55].push opt

    ans =
      op: BOOTREPLY
      htype: 1
      hlen: 6
      hops: 0
      xid: req.xid
      secs: 0
      flags: req.flags
      ciaddr: INADDR_ANY
      yiaddr: @_selectAddress req.chaddr
      siaddr: @config 'server'
      giaddr: req.giaddr
      chaddr: req.chaddr
      sname: ''
      file: ''
      options: @_getOptions { 53: DHCPOFFER }, [
        1
        3
        51
        54
        6
      ], req.options[55]

    console.log '<<< OFFER', JSON.stringify ans

    @_send @config('broadcast'), ans

  handleRequest: (req) ->
    lease = @_state[req.chaddr] = @_state[req.chaddr] or new Lease
    lease.address = @_selectAddress req.chaddr
    lease.leasePeriod = @config 'leaseTime'
    lease.server = @config 'server'
    lease.state = 'BOUND'
    lease.bindTime = new Date
    lease.file = req.file

    console.log '>>> REQUEST', JSON.stringify lease

    @sendAck req

  sendAck: (req) ->
    if req.options[97] and req.options[55].indexOf(97) == -1
      req.options[55].push 97

    if req.options[60] and req.options[60].indexOf('PXEClient') == 0
      [ 66, 67 ].forEach (opt) ->
        if req.options[55].indexOf(opt) is -1
          req.options[55].push opt

    ans =
      op: BOOTREPLY
      htype: 1
      hlen: 6
      hops: 0
      xid: req.xid
      secs: 0
      flags: req.flags
      ciaddr: req.ciaddr
      yiaddr: @_selectAddress req.chaddr
      siaddr: @config 'server'
      giaddr: req.giaddr
      chaddr: req.chaddr
      sname: ''
      file: ''
      options: @_getOptions { 53: DHCPACK }, [
        1
        3
        51
        54
        6
      ], req.options[55]

    @_send @config('broadcast'), ans, =>
      @emit 'bound', @_state, ans

  sendNak: (req) ->

    ans =
      op: BOOTREPLY
      htype: 1
      hlen: 6
      hops: 0
      xid: req.xid
      secs: 0
      flags: req.flags
      ciaddr: INADDR_ANY
      yiaddr: INADDR_ANY
      siaddr: INADDR_ANY
      giaddr: req.giaddr
      chaddr: req.chaddr
      sname: ''
      file: ''
      options: @_getOptions { 53: DHCPNAK }, [ 54 ]

    console.log '<<< NAK', JSON.stringify ans

    @_send @config('broadcast'), ans

  handleRelease: ->

  handleRenew: ->
    return

  listen: (port, host, fn = ->) ->
    connacks = 0

    onConnect = ->
      connacks++

      if connacks is 2
        process.nextTick fn

    @_sock.bind port or SERVER_PORT, host or INADDR_ANY, =>
      @_sock.setBroadcast true

      onConnect()

    @_sock6.bind 547, '::', =>
      @_sock6.setBroadcast true
      @_sock6.addMembership 'FF02::1:2'

      onConnect()

    @

  close: (callback) ->
    connacks = 0

    onClose = ->
      connacks++

      if connacks is 2
        callback()

    @_sock.close onClose
    @_sock6.close onClose

  _send: (host, data, cb = ->) ->
    sb = Protocol.format data

    @_sock.send sb._data, 0, sb._w, CLIENT_PORT, host, (err, bytes) ->
      if err
        console.log err

      cb err, bytes


module.exports = Server
