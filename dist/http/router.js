var HTTP_METHODS, METHODS, decode, error, formatter, matcher, noop, param, router, str;

param = function(val) {
  return function(map) {
    return map[val];
  };
};

str = function(val) {
  return function() {
    return val;
  };
};

formatter = function(format) {
  if (!format) {
    return null;
  }
  format = format.replace(/\{\*\}/g, '*').replace(/\*/g, '{*}').replace(/:(\w+)/g, '{$1}');
  format = format.match(/(?:[^\{]+)|(?:{[^\}]+\})/g).map(function(item) {
    if (item[0] !== '{') {
      return str(item);
    } else {
      return param(item.substring(1, item.length - 1));
    }
  });
  return function(params) {
    return format.reduce(function(result, item) {
      return result + item(params);
    }, '');
  };
};

decode = function(str) {
  var err;
  try {
    return decodeURIComponent(str);
  } catch (error1) {
    err = error1;
    return str;
  }
};

matcher = function(pattern) {
  var keys;
  if (typeof pattern !== 'string') {
    return function(url) {
      return url.match(pattern);
    };
  }
  keys = [];
  pattern = pattern.replace(/:(\w+)/g, '{$1}').replace('{*}', '*');
  pattern = pattern.replace(/(\/)?(\.)?\{([^}]+)\}(?:\(([^)]*)\))?(\?)?/g, function(match, slash, dot, key, capture, opt, offset) {
    var incl;
    incl = (pattern[match.length + offset] || '/') === '/';
    keys.push(key);
    return (incl ? '(?:' : '') + (slash || '') + (incl ? '' : '(?:') + (dot || '') + '(' + (capture || '[^/]+') + '))' + (opt || '');
  });
  pattern = pattern.replace(/([\/.])/g, '\\$1').replace(/\*/g, '(.+)');
  pattern = new RegExp('^' + pattern + '[\\/]?$', 'i');
  return function(str) {
    var map, match;
    match = str.match(pattern);
    if (!match) {
      return match;
    }
    map = {};
    match.slice(1).forEach(function(param, i) {
      var k;
      k = keys[i] = keys[i] || 'wildcard';
      param = param && decode(param);
      return map[k] = map[k] ? [].concat(map[k]).concat(param) : param;
    });
    if (map.wildcard) {
      map['*'] = map.wildcard;
    }
    return map;
  };
};

METHODS = ['get', 'post', 'put', 'del', 'delete', 'head', 'options'];

HTTP_METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'DELETE', 'HEAD', 'OPTIONS'];

noop = function() {};

error = function(res) {
  return function() {
    res.statusCode = 404;
    res.end();
  };
};

router = function() {
  var methods, route, traps;
  methods = {};
  traps = {};
  HTTP_METHODS.forEach(function(method) {
    return methods[method] = [];
  });
  route = function(req, res, next) {
    var i, index, lp, method, trap, url;
    method = methods[req.method];
    trap = traps[req.method];
    index = req.url.indexOf('?');
    url = index === -1 ? req.url : req.url.substr(0, index);
    i = 0;
    next = next || error(res);
    if (!method) {
      return next();
    }
    lp = function(err) {
      if (err) {
        return next(err);
      }
      while (i < method.length) {
        route = method[i];
        i++;
        req.params = route.pattern(url);
        if (!req.params) {
          continue;
        }
        if (route.rewrite) {
          req.url = url = route.rewrite(req.params) + (index === -1 ? '' : req.url.substr(index));
        }
        route.fn(req, res, lp);
        return;
      }
      if (!trap) {
        return next();
      }
      trap(req, res, next);
    };
    lp();
  };
  METHODS.forEach(function(method, i) {
    route[method] = function(pattern, rewrite, fn) {
      if (Array.isArray(pattern)) {
        pattern.forEach(function(item) {
          return route[method](item, rewrite, fn);
        });
      }
      if (!fn && !rewrite) {
        return route[method](null, null, pattern);
      }
      if (!fn && typeof rewrite === 'string') {
        return route[method](pattern, rewrite, route);
      }
      if (!fn && typeof rewrite === 'function') {
        return route[method](pattern, null, rewrite);
      }
      if (!fn) {
        return route;
      }
      (route.onmount || noop)(pattern, rewrite, fn);
      if (!pattern) {
        traps[HTTP_METHODS[i]] = fn;
        return route;
      }
      methods[HTTP_METHODS[i]].push({
        pattern: matcher(pattern),
        rewrite: formatter(rewrite),
        fn: fn
      });
      return route;
    };
  });
  route.all = function(pattern, rewrite, fn) {
    METHODS.forEach(function(method) {
      return route[method](pattern, rewrite, fn);
    });
    return route;
  };
  return route;
};

module.exports = router();
