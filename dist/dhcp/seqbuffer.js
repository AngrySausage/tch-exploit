var Options, SeqBuffer, trimZero,
  hasProp = {}.hasOwnProperty;

Options = require('./options').opts;

trimZero = function(str) {
  var pos;
  pos = str.indexOf('\u0000');
  if (pos === -1) {
    return str;
  } else {
    return str.substr(0, pos);
  }
};

SeqBuffer = (function() {
  function SeqBuffer(buf, len) {
    this._data = buf || Buffer.alloc(len || 1500);
  }

  SeqBuffer.prototype._data = null;

  SeqBuffer.prototype._r = 0;

  SeqBuffer.prototype._w = 0;

  SeqBuffer.prototype.addUInt8 = function(val) {
    return this._w = this._data.writeUInt8(val, this._w, true);
  };

  SeqBuffer.prototype.getUInt8 = function() {
    return this._data.readUInt8(this._r++, true);
  };

  SeqBuffer.prototype.addInt8 = function(val) {
    return this._w = this._data.writeInt8(val, this._w, true);
  };

  SeqBuffer.prototype.getInt8 = function() {
    return this._data.readInt8(this._r++, true);
  };

  SeqBuffer.prototype.addUInt16 = function(val) {
    return this._w = this._data.writeUInt16BE(val, this._w, true);
  };

  SeqBuffer.prototype.getUInt16 = function() {
    return this._data.readUInt16BE((this._r += 2) - 2, true);
  };

  SeqBuffer.prototype.addInt16 = function(val) {
    return this._w = this._data.writeInt16BE(val, this._w, true);
  };

  SeqBuffer.prototype.getInt16 = function() {
    return this._data.readInt16BE((this._r += 2) - 2, true);
  };

  SeqBuffer.prototype.addUInt32 = function(val) {
    return this._w = this._data.writeUInt32BE(val, this._w, true);
  };

  SeqBuffer.prototype.getUInt32 = function() {
    return this._data.readUInt32BE((this._r += 4) - 4, true);
  };

  SeqBuffer.prototype.addInt32 = function(val) {
    return this._w = this._data.writeInt32BE(val, this._w, true);
  };

  SeqBuffer.prototype.getInt32 = function() {
    return this._data.readInt32BE((this._r += 4) - 4, true);
  };

  SeqBuffer.prototype.addUTF8 = function(val) {
    return this._w += this._data.write(val, this._w, 'utf8');
  };

  SeqBuffer.prototype.addUTF8Pad = function(val, fixLen) {
    var len, n;
    len = Buffer.from(val, 'utf8').length;
    n = 0;
    while (len > fixLen) {
      val = val.slice(0, fixLen - n);
      len = Buffer.from(val, 'utf8').length;
      n++;
    }
    this._data.fill(0, this._w, this._w + fixLen);
    this._data.write(val, this._w, 'utf8');
    return this._w += fixLen;
  };

  SeqBuffer.prototype.getUTF8 = function(len) {
    return trimZero(this._data.toString('utf8', this._r, this._r += len));
  };

  SeqBuffer.prototype.addASCII = function(val) {
    return this._w += this._data.write(val, this._w, 'ascii');
  };

  SeqBuffer.prototype.addASCIIPad = function(val, fixLen) {
    this._data.fill(0, this._w, this._w + fixLen);
    this._data.write(val.slice(0, fixLen), this._w, 'ascii');
    return this._w += fixLen;
  };

  SeqBuffer.prototype.getASCII = function(len) {
    return trimZero(this._data.toString('ascii', this._r, this._r += len));
  };

  SeqBuffer.prototype.addIP = function(ip) {
    var j, len1, octs, results, val;
    if (typeof ip !== 'string') {
      return;
    }
    octs = ip.split('.');
    if (octs.length !== 4) {
      throw new Error('Invalid IP address ' + ip);
    }
    results = [];
    for (j = 0, len1 = octs.length; j < len1; j++) {
      val = octs[j];
      val = parseInt(val, 10);
      if (0 <= val && val < 256) {
        results.push(this.addUInt8(val));
      } else {
        throw new Error('Invalid IP address ' + ip);
      }
    }
    return results;
  };

  SeqBuffer.prototype.getIP = function() {
    return this.getUInt8() + '.' + this.getUInt8() + '.' + this.getUInt8() + '.' + this.getUInt8();
  };

  SeqBuffer.prototype.addIPs = function(ips) {
    var ip, j, len1, results;
    if (ips instanceof Array) {
      results = [];
      for (j = 0, len1 = ips.length; j < len1; j++) {
        ip = ips[j];
        results.push(this.addIP(ip));
      }
      return results;
    } else {
      return this.addIP(ips);
    }
  };

  SeqBuffer.prototype.getIPs = function(len) {
    var i, ret;
    ret = [];
    i = 0;
    while (i < len) {
      ret.push(this.getIP());
      i += 4;
    }
    return ret;
  };

  SeqBuffer.prototype.addHex = function(val, fixLen) {
    if (fixLen) {
      this._data.fill(0, this._w, this._w + fixLen);
      this._data.write(val.slice(0, fixLen), this._w, 'hex');
      return this._w += fixLen;
    } else {
      return this._w += this._data.write(val, this._w, 'hex');
    }
  };

  SeqBuffer.prototype.getHEX = function(hlen) {
    return this._data.toString('hex', this._r, this._r += hlen);
  };

  SeqBuffer.prototype.addMac = function(mac) {
    var j, len1, octs, val;
    octs = mac.split(/[-:]/);
    if (octs.length !== 6) {
      throw new Error('Invalid Mac address ' + mac);
    }
    for (j = 0, len1 = octs.length; j < len1; j++) {
      val = octs[j];
      val = parseInt(val, 16);
      if (0 <= val && val < 256) {
        this.addUInt8(val);
      } else {
        throw new Error('Invalid Mac address ' + mac);
      }
    }
    this.addUInt32(0);
    this.addUInt32(0);
    return this.addUInt16(0);
  };

  SeqBuffer.prototype.getMAC = function(htype, hlen) {
    var mac;
    mac = this._data.toString('hex', this._r, this._r += hlen);
    if (htype !== 1 || hlen !== 6) {
      throw new Error('Invalid hardware address (len=' + hlen + ', type=' + htype + ')');
    }
    this._r += 10;
    return mac.toUpperCase().match(/../g).join('-');
  };

  SeqBuffer.prototype.addBool = function() {};

  SeqBuffer.prototype.getBool = function() {
    return true;
  };

  SeqBuffer.prototype.addOptions = function(opts) {
    var i, len, n, opt, results, val;
    results = [];
    for (i in opts) {
      if (!hasProp.call(opts, i)) continue;
      val = opts[i];
      opt = Options[i];
      len = 0;
      if (val === null) {
        i += 4;
        continue;
      }
      switch (opt.type) {
        case 'UInt8':
        case 'Int8':
          len = 1;
          break;
        case 'UInt16':
        case 'Int16':
          len = 2;
          break;
        case 'UInt32':
        case 'Int32':
        case 'IP':
          len = 4;
          break;
        case 'IPs':
          len = val instanceof Array ? 4 * val.length : 4;
          break;
        case 'ASCII':
          len = val.length;
          if (len === 0) {
            i += 4;
            continue;
          }
          if (len > 255) {
            console.error(val + ' too long, truncating...');
            val = val.slice(0, 255);
            len = 255;
          }
          break;
        case 'HEX':
          len = val.length;
          if (len === 0) {
            continue;
          }
          if (len > 255) {
            console.error(val + ' too long, truncating...');
            val = val.slice(0, 255);
            len = 255;
          }
          break;
        case 'UTF8':
          len = Buffer.from(val, 'utf8').length;
          if (len === 0) {
            i += 4;
            continue;
          }
          n = 0;
          while (len > 255) {
            val = val.slice(0, 255 - n);
            len = Buffer.from(val, 'utf8').length;
            n++;
          }
          break;
        case 'Bool':
          if (!(val === true || val === 1 || val === '1' || val === 'true' || val === 'TRUE' || val === 'True')) {
            n++;
            continue;
          }
          break;
        case 'UInt8s':
          len = val instanceof Array ? val.length : 1;
          break;
        case 'UInt16s':
          len = val instanceof Array ? 2 * val.length : 2;
          break;
        default:
          throw new Error('No such type ' + opt.type);
      }
      this.addUInt8(i);
      this.addUInt8(len);
      results.push(this['add' + opt.type](val));
    }
    return results;
  };

  SeqBuffer.prototype.getOptions = function() {
    var buf, len, opt, options;
    options = {};
    buf = this._data;
    while (this._r < buf.length) {
      opt = this.getUInt8();
      if (opt === 0xff) {
        break;
      } else if (opt === 0x00) {
        this._r++;
      } else {
        len = this.getUInt8();
        if (opt in Options) {
          options[opt] = this['get' + Options[opt].type](len);
        } else {
          this._r += len;
          console.error('Option ' + opt + ' not known');
        }
      }
    }
    return options;
  };

  SeqBuffer.prototype.addUInt8s = function(arr) {
    var i, results;
    if (arr instanceof Array) {
      i = 0;
      results = [];
      while (i < arr.length) {
        this.addUInt8(arr[i]);
        results.push(i++);
      }
      return results;
    } else {
      return this.addUInt8(arr);
    }
  };

  SeqBuffer.prototype.getUInt8s = function(len) {
    var i, ret;
    ret = [];
    i = 0;
    while (i < len) {
      ret.push(this.getUInt8());
      i++;
    }
    return ret;
  };

  SeqBuffer.prototype.addUInt16s = function(arr) {
    var i, results;
    if (arr instanceof Array) {
      i = 0;
      results = [];
      while (i < arr.length) {
        this.addUInt16(arr[i]);
        results.push(i++);
      }
      return results;
    } else {
      return this.addUInt16(arr);
    }
  };

  SeqBuffer.prototype.getUInt16s = function(len) {
    var i, ret;
    ret = [];
    i = 0;
    while (i < len) {
      ret.push(this.getUInt16());
      i += 2;
    }
    return ret;
  };

  SeqBuffer.prototype.getHex = function(len) {
    return this._data.toString('hex', this._r, this._r += len);
  };

  return SeqBuffer;

})();

module.exports = SeqBuffer;
