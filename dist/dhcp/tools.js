module.exports = {
  parseIp: function(str) {
    var octs;
    octs = str.split('.');
    if (octs.length !== 4) {
      throw new Error('Invalid IP address ' + str);
    }
    return octs.reduce(function(prev, val) {
      val = parseInt(val, 10);
      if (0 <= val && val < 256) {
        return prev << 8 | val;
      } else {
        throw new Error('Invalid IP address ' + str);
      }
    }, 0);
  },
  formatIp: function(num) {
    var i, ip;
    ip = '';
    i = 24;
    while (i >= 0) {
      if (ip) {
        ip += '.';
      }
      ip += (num >>> i & 0xFF).toString(10);
      i -= 8;
    }
    return ip;
  },
  netmaskFromCIDR: function(cidr) {
    return -1 << 32 - cidr;
  },
  netmaskFromIP: function(ip) {
    var first;
    if (typeof ip === 'string') {
      ip = this.parseIp(ip);
    }
    first = ip >>> 24;
    if (first <= 127) {
      return 0xff000000;
    } else if (first >= 192) {
      return 0xffffff00;
    } else {
      return 0xffff0000;
    }
  },
  wildcardFromCIDR: function(cidr) {
    return ~this.netmaskFromCIDR(cidr);
  },
  networkFromIpCIDR: function(ip, cidr) {
    if (typeof ip === 'string') {
      ip = this.parseIp(ip);
    }
    return this.netmaskFromCIDR(cidr) & ip;
  },
  broadcastFromIpCIDR: function(ip, cidr) {
    if (typeof ip === 'string') {
      ip = this.parseIp(ip);
    }
    return this.networkFromIpCIDR(ip, cidr) | this.wildcardFromCIDR(cidr);
  },
  CIDRFromNetmask: function(net) {
    var d, i, s, t, wild;
    if (typeof net === 'string') {
      net = this.parseIp(net);
    }
    s = 0;
    d = 0;
    t = net & 1;
    wild = t;
    i = 0;
    while (i < 32) {
      d += t ^ net & 1;
      t = net & 1;
      net >>>= 1;
      s += t;
      i++;
    }
    if (d !== 1) {
      throw new Error('Invalid Netmask ' + net);
    }
    if (wild) {
      s = 32 - s;
    }
    return s;
  },
  gatewayFromIpCIDR: function(ip, cidr) {
    if (typeof ip === 'string') {
      ip = this.parseIp(ip);
    }
    if (cidr === 32) {
      return ip;
    }
    return this.networkFromIpCIDR(ip, cidr) + 1;
  },
  netmaskFromRange: function(ip1, ip2) {
    var cidr;
    if (typeof ip1 === 'string') {
      ip1 = this.parseIp(ip1);
    }
    if (typeof ip2 === 'string') {
      ip2 = this.parseIp(ip2);
    }
    cidr = 32 - Math.floor(Math.log2((ip1 ^ ip2 - 1) + 2)) - 1;
    return this.netmaskFromCIDR(cidr);
  }
};
