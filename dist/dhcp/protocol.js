var SeqBuffer;

SeqBuffer = require('./seqbuffer');

module.exports = {
  parse: function(buf) {
    var hlen, htype, sb;
    if (buf.length < 230) {
      throw new Error('Received data is too short');
    }
    sb = new SeqBuffer(buf);
    return {
      op: sb.getUInt8(),
      htype: htype = sb.getUInt8(),
      hlen: hlen = sb.getUInt8(),
      hops: sb.getUInt8(),
      xid: sb.getUInt32(),
      secs: sb.getUInt16(),
      flags: sb.getUInt16(),
      ciaddr: sb.getIP(),
      yiaddr: sb.getIP(),
      siaddr: sb.getIP(),
      giaddr: sb.getIP(),
      chaddr: sb.getMAC(htype, hlen),
      sname: sb.getUTF8(64),
      file: sb.getUTF8(128),
      magicCookie: sb.getUInt32(),
      options: sb.getOptions()
    };
  },
  format: function(data) {
    var sb;
    sb = new SeqBuffer;
    sb.addUInt8(data.op);
    sb.addUInt8(data.htype);
    sb.addUInt8(data.hlen);
    sb.addUInt8(data.hops);
    sb.addUInt32(data.xid);
    sb.addUInt16(data.secs);
    sb.addUInt16(data.flags);
    sb.addIP(data.ciaddr);
    sb.addIP(data.yiaddr);
    sb.addIP(data.siaddr);
    sb.addIP(data.giaddr);
    sb.addMac(data.chaddr);
    sb.addUTF8Pad(data.sname, 64);
    sb.addUTF8Pad(data.file, 128);
    sb.addUInt32(0x63825363);
    sb.addOptions(data.options);
    sb.addUInt8(255);
    return sb;
  },
  parseIpv6: function(msg, rinfo) {
    var DUIDType, codeName, hopCount, i, i6, iBuf, interfaceID, linkAddress, linkHex, linkPre, num, o, offset, optionCode, optionLen, options, peerAddress, peerHex, peerPre, prot, readAddressRaw, relayBuf, xid;
    options = {
      op: msg.readUInt8(0)
    };
    offset = 0;
    readAddressRaw = function(msg, offset, len) {
      var addr, b;
      addr = '';
      while (len-- > 0) {
        b = msg.readUInt8(offset++);
        addr += (b + 0x100).toString(16).substr(-2);
        if (len > 0) {
          addr += ':';
        }
      }
      return addr;
    };
    if (options.op === 12) {
      hopCount = msg.readUInt8(1);
      linkAddress = '';
      i = 2;
      while (i < 18) {
        if (i !== 2) {
          linkAddress = linkAddress + ':';
        }
        linkHex = msg.readUInt16BE(i).toString(16);
        linkPre = (function() {
          switch (linkHex.length) {
            case 3:
              return '0';
            case 2:
              return '00';
            case 1:
              return '000';
            default:
              return '';
          }
        })();
        linkAddress = linkAddress + linkPre + linkHex;
        i = i + 2;
      }
      linkAddress = linkAddress;
      peerAddress = '';
      o = 18;
      while (o < 34) {
        if (o !== 18) {
          peerAddress = peerAddress + ':';
        }
        peerHex = msg.readUInt16BE(o).toString(16);
        peerPre = (function() {
          switch (peerHex.length) {
            case 3:
              return '0';
            case 2:
              return '00';
            case 1:
              return '000';
            default:
              return '';
          }
        })();
        peerAddress = peerAddress + peerPre + peerHex;
        o = o + 2;
      }
      peerAddress = peerAddress;
      offset = 33;
    } else {
      xid = msg.readUInt8(1).toString(16) + msg.readUInt8(2).toString(16) + msg.readUInt8(3).toString(16);
      options.xid = (function() {
        switch (xid.length) {
          case 1:
            return '00000' + xid;
          case 2:
            return '0000' + xid;
          case 3:
            return '000' + xid;
          case 4:
            return '00' + xid;
          case 5:
            return '0' + xid;
        }
      })();
      offset = 3;
    }
    while (offset < msg.length - 1) {
      optionCode = msg.readInt16BE(offset + 1);
      optionLen = msg.readInt16BE(offset + 3);
      offset = offset + 4;
      switch (optionCode) {
        case 1:
          DUIDType = msg.readUInt16BE(offset + 1);
          iBuf = new Buffer(optionLen);
          msg.copy(iBuf, 0, offset + 1, offset + 1 + optionLen);
          options.clientIdentifierOption = (function() {
            switch (DUIDType) {
              case 1:
                return {
                  buffer: iBuf,
                  DUIDType: DUIDType,
                  hardwareType: msg.readUInt16BE(offset + 3),
                  time: msg.readUInt32BE(offset + 5),
                  linkLayerAddress: readAddressRaw(msg, offset + 9, optionLen - 8)
                };
              case 2:
                return {
                  buffer: iBuf,
                  DUIDType: DUIDType,
                  enterpriseNumber: void 0,
                  enterpriseNumberContd: void 0,
                  identifier: void 0
                };
              case 3:
                return {
                  buffer: iBuf,
                  DUIDType: DUIDType,
                  hardwareType: msg.readUInt16BE(offset + 3),
                  linkLayerAddress: readAddressRaw(msg, offset + 5, optionLen - 4)
                };
            }
          })();
          offset += optionLen;
          break;
        case 2:
          DUIDType = msg.readUInt16BE(offset + 1);
          iBuf = new Buffer(optionLen);
          msg.copy(iBuf, 0, offset + 1, offset + 1 + optionLen);
          options.serverIdentifierOption = (function() {
            switch (DUIDType) {
              case 1:
                return {
                  buffer: iBuf,
                  DUIDType: DUIDType,
                  hardwareType: msg.readUInt16BE(offset + 3),
                  time: msg.readUInt32BE(offset + 5),
                  linkLayerAddress: readAddressRaw(msg, offset + 9, optionLen - 8)
                };
              case 2:
                return {
                  buffer: iBuf,
                  DUIDType: DUIDType,
                  enterpriseNumber: void 0,
                  enterpriseNumberContd: void 0,
                  identifier: void 0
                };
              case 3:
                return {
                  buffer: iBuf,
                  DUIDType: DUIDType,
                  hardwareType: msg.readUInt16BE(offset + 3),
                  linkLayerAddress: readAddressRaw(msg, offset + 5, optionLen - 4)
                };
            }
          })();
          offset += optionLen;
          break;
        case 3:
          options.IA_NA = {
            IAID: msg.readUInt32BE(offset + 1),
            T1: msg.readUInt32BE(offset + 5),
            T2: msg.readUInt32BE(offset + 9)
          };
          offset += optionLen;
          break;
        case 6:
          options.request = [];
          options.requestDesc = [];
          i6 = 1;
          while (i6 < optionLen) {
            num = msg.readUInt16BE(offset + i6);
            prot = protocol.DHCPv6OptionsCode.get(num);
            if (prot && prot.name) {
              options.requestDesc.push(prot.name);
            }
            options.request.push(num);
            i6 = i6 + 2;
          }
          offset += optionLen;
          break;
        case 8:
          options.elapsedTime = msg.readUInt16BE(offset + 1);
          offset += optionLen;
          break;
        case 9:
          relayBuf = new Buffer(optionLen);
          msg.copy(relayBuf, 0, offset + 1, offset + 1 + optionLen);
          options.dhcpRelayMessage = parser6.parse(relayBuf, rinfo);
          offset += optionLen;
          break;
        case 18:
          interfaceID = new Buffer(optionLen);
          msg.copy(interfaceID, 0, offset + 1, offset + 1 + optionLen);
          options.interfaceID = {
            hex: msg.toString('hex', offset + 1, offset + 1 + optionLen),
            buffer: interfaceID
          };
          offset += optionLen;
          break;
        case 25:
          options.IA_PD = {
            IAID: msg.readUInt32BE(offset + 1),
            T1: msg.readUInt32BE(offset + 5),
            T2: msg.readUInt32BE(offset + 9)
          };
          offset += optionLen;
          break;
        case 37:
          options.relayAgentRemoteID = {
            enterpriseNumber: msg.readUInt32BE(offset + 1),
            remoteId: msg.toString('hex', offset + 5, offset + 1 + optionLen)
          };
          offset += optionLen;
          break;
        case 39:
          options.clientFQDN = {
            flags: msg.readUInt8(offset + 1),
            domainName: msg.toString('utf8', offset + 2, offset + 1 + optionLen)
          };
          offset += optionLen;
          break;
        default:
          codeName = DHCPV6.OPTIONSCODE[optionCode];
          console.log('Unhandled DHCPv6 option ' + optionCode + ' (' + codeName + ')/' + optionLen + 'b');
          offset += optionLen;
          break;
      }
    }
    return options;
  }
};
