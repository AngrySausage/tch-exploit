var BOOTREPLY, BOOTREQUEST, CLIENT_PORT, DHCPACK, DHCPDECLINE, DHCPDISCOVER, DHCPINFORM, DHCPNAK, DHCPOFFER, DHCPRELEASE, DHCPREQUEST, DHCPV6, EventEmitter, INADDR_ANY, INADDR_BROADCAST, Ips, Lease, Options, Protocol, SERVER_PORT, SeqBuffer, Server, Tools, dgram, os, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

dgram = require('dgram');

os = require('os');

EventEmitter = require('events').EventEmitter;

Lease = require('./lease');

SeqBuffer = require('./seqbuffer');

Options = require('./options');

Protocol = require('./protocol');

Tools = require('./tools');

Ips = require('../ips');

ref = require('./constants'), DHCPDISCOVER = ref.DHCPDISCOVER, DHCPOFFER = ref.DHCPOFFER, DHCPREQUEST = ref.DHCPREQUEST, DHCPDECLINE = ref.DHCPDECLINE, DHCPACK = ref.DHCPACK, DHCPNAK = ref.DHCPNAK, DHCPRELEASE = ref.DHCPRELEASE, DHCPINFORM = ref.DHCPINFORM, SERVER_PORT = ref.SERVER_PORT, CLIENT_PORT = ref.CLIENT_PORT, INADDR_ANY = ref.INADDR_ANY, INADDR_BROADCAST = ref.INADDR_BROADCAST, BOOTREQUEST = ref.BOOTREQUEST, BOOTREPLY = ref.BOOTREPLY, DHCPV6 = ref.DHCPV6;

Server = (function(superClass) {
  extend(Server, superClass);

  Server.createServer = function(opt) {
    return new Server(opt);
  };

  function Server(config) {
    var sock, sock6;
    Server.__super__.constructor.apply(this, arguments);
    sock = dgram.createSocket({
      type: 'udp4',
      reuseAddr: true
    });
    sock.on('message', this.ipv4Message.bind(this));
    sock.on('listening', (function(_this) {
      return function() {
        return _this.emit('listening', sock, '');
      };
    })(this));
    sock.on('close', (function(_this) {
      return function() {
        return _this.emit('close');
      };
    })(this));
    sock6 = dgram.createSocket({
      type: 'udp6',
      reuseAddr: true
    });
    sock6.on('message', this.ipv6Message.bind(this));
    sock6.on('listening', (function(_this) {
      return function() {
        return _this.emit('listening', sock6, 'v6');
      };
    })(this));
    sock6.on('close', (function(_this) {
      return function() {
        return _this.emit('close');
      };
    })(this));
    this._sock6 = sock6;
    this._sock = sock;
    this._conf = config;
    this._state = {};
  }

  Server.prototype.ipv4Message = function(buf) {
    var e, req;
    try {
      req = Protocol.parse(buf);
    } catch (error) {
      e = error;
      this.emit('error', e);
      return;
    }
    this.emit('message', req);
    if (req.op !== BOOTREQUEST) {
      this.emit('error', new Error('Malformed packet'), req);
      return;
    }
    if (!req.options[53]) {
      return this.handleRequest(req);
    }
    switch (req.options[53]) {
      case DHCPDISCOVER:
        return this.handleDiscover(req);
      case DHCPREQUEST:
        return this.handleRequest(req);
    }
  };

  Server.prototype.ipv6Message = function(buf, rinfo) {
    var e, req;
    try {
      req = Protocol.parseIpv6(buf);
    } catch (error) {
      e = error;
      this.emit('error', e);
      return;
    }
    this.emit('message', req);
    return this.emit(DHCPV6.MESSAGETYPE[req.op], req, rinfo);
  };

  Server.prototype.config = function(key) {
    var i, optId, ref1, v, val, values;
    optId = Options.conf[key];
    if (void 0 !== this._conf[key]) {
      val = this._conf[key];
    } else if (void 0 !== Options.opts[optId]) {
      val = Options.opts[optId]["default"];
      if (val === void 0) {
        return 0;
      }
    } else {
      throw new Error('Invalid option ' + key);
    }
    if (val instanceof Function) {
      val = val.call(this);
    }
    values = (ref1 = Options.opts[optId]) != null ? ref1["enum"] : void 0;
    if ((key !== 'range' && key !== 'static' && key !== 'randomIP') && values) {
      for (i in values) {
        v = values[i];
        if (v === val) {
          return parseInt(i, 10);
        }
      }
      if (values[val] === void 0) {
        throw new Error('Provided enum value for ' + key + ' is not valid');
      } else {
        val = parseInt(val, 10);
      }
    }
    return val;
  };

  Server.prototype._getOptions = function(pre, required, requested) {
    var forceOptions, id, j, k, l, len, len1, len2, option, req, val;
    for (j = 0, len = required.length; j < len; j++) {
      req = required[j];
      if (Options.opts[req] !== void 0) {
        if (pre[req] == null) {
          pre[req] = this.config(Options.opts[req].config);
        }
        if (!pre[req]) {
          throw new Error("Required option " + Options.opts[req].config + " does not have a value set");
        }
      } else {
        this.emit('error', 'Unknown option ' + req);
      }
    }
    if (requested) {
      for (k = 0, len1 = requested.length; k < len1; k++) {
        req = requested[k];
        if (Options.opts[req] !== void 0 && pre[req] === void 0) {
          val = this.config(Options.opts[req].config);
          if (val) {
            pre[req] = val;
          }
        } else {
          this.emit('error', 'Unknown option ' + req);
        }
      }
    }
    forceOptions = this._conf.forceOptions;
    if (Array.isArray(forceOptions)) {
      for (l = 0, len2 = forceOptions.length; l < len2; l++) {
        option = forceOptions[l];
        if (isNaN(option)) {
          id = Options.conf[option];
        } else {
          id = option;
        }
        if ((id != null) && pre[id] === void 0) {
          pre[id] = this.config(option);
        }
      }
    }
    return pre;
  };

  Server.prototype._selectAddress = function(clientMAC, req) {
    var _static, _tmp, firstIP, i, ip, ips, lastIP, leases, mac, oldestMac, oldestTime, randIP, ref1, ref2, staticResult, v;
    if ((ref1 = this._state[clientMAC]) != null ? ref1.address : void 0) {
      return this._state[clientMAC].address;
    }
    _static = this.config('static');
    if (typeof _static === 'function') {
      staticResult = _static(clientMAC, req);
      if (staticResult) {
        return staticResult;
      }
    } else if (_static[clientMAC]) {
      return _static[clientMAC];
    }
    randIP = this.config('randomIP');
    _tmp = this.config('range');
    firstIP = Tools.parseIp(_tmp[0]);
    lastIP = Tools.parseIp(_tmp[1]);
    ips = [this.config('server')];
    oldestMac = null;
    oldestTime = 2e308;
    leases = 0;
    ref2 = this._state;
    for (mac in ref2) {
      v = ref2[mac];
      if (v.address) {
        ips.push(v.address);
      }
      if (v.leaseTime < oldestTime) {
        oldestTime = v.leaseTime;
        oldestMac = mac;
      }
      leases++;
    }
    if (oldestMac && lastIP - firstIP === leases) {
      ip = this._state[oldestMac].address;
      delete this._state[oldestMac];
      return ip;
    }
    if (randIP) {
      while (true) {
        ip = Tools.formatIp(firstIP + Math.random() * (lastIP - firstIP) | 0);
        if (ips.indexOf(ip) === -1) {
          return ip;
        }
      }
    }
    i = firstIP;
    while (i <= lastIP) {
      ip = Tools.formatIp(i);
      if (indexOf.call(ips, ip) < 0) {
        return ip;
      }
      i++;
    }
  };

  Server.prototype.handleDiscover = function(req) {
    var lease;
    lease = this._state[req.chaddr] = this._state[req.chaddr] || new Lease;
    lease.address = this._selectAddress(req.chaddr, req);
    lease.leasePeriod = this.config('leaseTime');
    lease.server = this.config('server');
    lease.state = 'OFFERED';
    console.log('>>> DISCOVER', JSON.stringify(lease));
    return this.sendOffer(req);
  };

  Server.prototype.sendOffer = function(req) {
    var ans;
    if (req.options[97] && req.options[55].indexOf(97) === -1) {
      req.options[55].push(97);
    }
    if (req.options[60] && req.options[60].indexOf('PXEClient') === 0) {
      [66, 67].forEach(function(opt) {
        if (req.options[55].indexOf(opt) === -1) {
          return req.options[55].push(opt);
        }
      });
    }
    ans = {
      op: BOOTREPLY,
      htype: 1,
      hlen: 6,
      hops: 0,
      xid: req.xid,
      secs: 0,
      flags: req.flags,
      ciaddr: INADDR_ANY,
      yiaddr: this._selectAddress(req.chaddr),
      siaddr: this.config('server'),
      giaddr: req.giaddr,
      chaddr: req.chaddr,
      sname: '',
      file: '',
      options: this._getOptions({
        53: DHCPOFFER
      }, [1, 3, 51, 54, 6], req.options[55])
    };
    console.log('<<< OFFER', JSON.stringify(ans));
    return this._send(this.config('broadcast'), ans);
  };

  Server.prototype.handleRequest = function(req) {
    var lease;
    lease = this._state[req.chaddr] = this._state[req.chaddr] || new Lease;
    lease.address = this._selectAddress(req.chaddr);
    lease.leasePeriod = this.config('leaseTime');
    lease.server = this.config('server');
    lease.state = 'BOUND';
    lease.bindTime = new Date;
    lease.file = req.file;
    console.log('>>> REQUEST', JSON.stringify(lease));
    return this.sendAck(req);
  };

  Server.prototype.sendAck = function(req) {
    var ans;
    if (req.options[97] && req.options[55].indexOf(97) === -1) {
      req.options[55].push(97);
    }
    if (req.options[60] && req.options[60].indexOf('PXEClient') === 0) {
      [66, 67].forEach(function(opt) {
        if (req.options[55].indexOf(opt) === -1) {
          return req.options[55].push(opt);
        }
      });
    }
    ans = {
      op: BOOTREPLY,
      htype: 1,
      hlen: 6,
      hops: 0,
      xid: req.xid,
      secs: 0,
      flags: req.flags,
      ciaddr: req.ciaddr,
      yiaddr: this._selectAddress(req.chaddr),
      siaddr: this.config('server'),
      giaddr: req.giaddr,
      chaddr: req.chaddr,
      sname: '',
      file: '',
      options: this._getOptions({
        53: DHCPACK
      }, [1, 3, 51, 54, 6], req.options[55])
    };
    return this._send(this.config('broadcast'), ans, (function(_this) {
      return function() {
        return _this.emit('bound', _this._state, ans);
      };
    })(this));
  };

  Server.prototype.sendNak = function(req) {
    var ans;
    ans = {
      op: BOOTREPLY,
      htype: 1,
      hlen: 6,
      hops: 0,
      xid: req.xid,
      secs: 0,
      flags: req.flags,
      ciaddr: INADDR_ANY,
      yiaddr: INADDR_ANY,
      siaddr: INADDR_ANY,
      giaddr: req.giaddr,
      chaddr: req.chaddr,
      sname: '',
      file: '',
      options: this._getOptions({
        53: DHCPNAK
      }, [54])
    };
    console.log('<<< NAK', JSON.stringify(ans));
    return this._send(this.config('broadcast'), ans);
  };

  Server.prototype.handleRelease = function() {};

  Server.prototype.handleRenew = function() {};

  Server.prototype.listen = function(port, host, fn) {
    var connacks, ip, onConnect;
    if (fn == null) {
      fn = function() {};
    }
    ip = Ips().find(function(arg) {
      var family;
      family = arg.family;
      return family === 'IPv6';
    });
    connacks = Number(!!ip);
    onConnect = function() {
      connacks++;
      if (connacks === 2) {
        return process.nextTick(fn);
      }
    };
    this._sock.bind(port || SERVER_PORT, host || INADDR_ANY, (function(_this) {
      return function() {
        _this._sock.setBroadcast(true);
        return onConnect();
      };
    })(this));
    if (ip) {
      this._sock6.bind(547, '::', (function(_this) {
        return function() {
          var e;
          _this._sock6.setBroadcast(true);
          try {
            _this._sock6.addMembership(ip.address);
          } catch (error) {
            e = error;
          }
          return onConnect();
        };
      })(this));
    }
    return this;
  };

  Server.prototype.close = function(callback) {
    var connacks, onClose;
    connacks = 0;
    onClose = function() {
      connacks++;
      if (connacks === 2) {
        return callback();
      }
    };
    this._sock.close(onClose);
    return this._sock6.close(onClose);
  };

  Server.prototype._send = function(host, data, cb) {
    var sb;
    if (cb == null) {
      cb = function() {};
    }
    sb = Protocol.format(data);
    return this._sock.send(sb._data, 0, sb._w, CLIENT_PORT, host, function(err, bytes) {
      if (err) {
        console.log(err);
      }
      return cb(err, bytes);
    });
  };

  return Server;

})(EventEmitter);

module.exports = Server;
